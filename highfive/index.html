<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Realtime Space Counter</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <style>
    :root { --muted: rgba(0,0,0,0.55); --good:#16a34a; --warn:#f59e0b; --bad:#ef4444; }
    html,body{height:100%;margin:0;font-family:Inter,system-ui,-apple-system,Segoe UI,Roboto,"Helvetica Neue",Arial}
    body{
      /* put your background image file next to this file and name it background.jpg */
      background-image: url("background.jpg");
      background-size: cover;
      background-position: center;
      background-repeat: no-repeat;
      display:flex;
      align-items:center;
      justify-content:center;
      color:#000;
    }

    .wrap{
      width:100%;
      max-width:980px;
      margin:24px;
      padding:24px;
      background: rgba(255,255,255,0.0);
      border-radius:18px;
      text-align:center;
      position:relative;
    }

    /* status badge top-right */
    .status-badge{
      position: fixed;
      top: 18px;
      right: 18px;
      display:flex;
      gap:10px;
      align-items:center;
      background: rgba(255,255,255,0.9);
      color:#000;
      padding:8px 12px;
      border-radius:999px;
      box-shadow: 0 6px 20px rgba(0,0,0,0.12);
      font-weight:700;
      font-size:13px;
      z-index:12000;
    }
    .status-dot{
      width:12px;
      height:12px;
      border-radius:50%;
      background:var(--bad);
      flex:0 0 12px;
      box-shadow:0 0 8px rgba(0,0,0,0.12);
    }
    .status-text { font-size:13px; color: #000; }

    /* big centered number */
    .count-box{
      display:flex;
      align-items:center;
      justify-content:center;
      width:100%;
      height:260px;
      margin:10px auto;
      user-select:none;
      background: rgba(255,255,255,0.92); /* white panel so black number is readable */
      border-radius:20px;
      box-shadow: 0 10px 40px rgba(0,0,0,0.12);
    }
    .count{
      font-size:140px;
      font-weight:900;
      color:#000;
      line-height:0.95;
    }

    .info { color:white; margin-top:12px; font-size:14px; }

    /* local queued info */
    .local { color:var(--muted); font-size:13px; margin-top:10px; }

    /* goal UI row */
    .goal-row { margin-top:14px; display:flex; gap:8px; align-items:center; justify-content:center; }
    input[type=number] { padding:8px 10px; border-radius:8px; border:1px solid rgba(0,0,0,0.08); background:rgba(255,255,255,0.95); color:#000; width:130px; text-align:center; font-weight:700; }
    button { padding:9px 12px; border-radius:10px; border:1px solid rgba(0,0,0,0.08); background:rgba(255,255,255,0.95); font-weight:700; cursor:pointer; }

    /* large goal bottom center */
    .goal-bottom{
      position: fixed;
      left: 50%;
      transform: translateX(-50%);
      bottom: 18px;
      background: rgba(255,255,255,0.92);
      padding:12px 20px;
      border-radius:999px;
      box-shadow:0 8px 30px rgba(0,0,0,0.12);
      font-weight:900;
      font-size:22px;
      color:#000;
      z-index:11000;
    }

    .offline-bar { position:fixed; left:0; right:0; bottom:0; background:#b91c1c; color:white; padding:10px 14px; text-align:center; font-weight:700; display:none; z-index:9999; }

    /* confetti */
    .confetti{ position: fixed; pointer-events:none; left:0; top:0; right:0; bottom:0; overflow:visible; z-index:9998; }
    .confetti-piece{ position:absolute; width:10px; height:14px; opacity:0.95; transform-origin:center; will-change: transform, top, left; border-radius:2px; }

    /* small flash when blocked */
    .flash{
      animation: flashAnim 280ms ease-in-out;
    }
    @keyframes flashAnim {
      0% { box-shadow: 0 0 0 0 rgba(239,68,68,0.0); transform: scale(1); }
      40% { box-shadow: 0 0 0 10px rgba(239,68,68,0.08); transform: scale(1.02); }
      100% { box-shadow: 0 0 0 0 rgba(239,68,68,0.0); transform: scale(1); }
    }
  </style>

  <!-- Firebase compat SDK -->
  <script src="https://www.gstatic.com/firebasejs/9.22.1/firebase-app-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.22.1/firebase-database-compat.js"></script>
</head>
<body>
  <div class="status-badge" id="statusBadge" aria-live="polite">
    <div class="status-dot" id="statusDot" title="connection status"></div>
    <div>
      <div class="status-text" id="statusText">Connecting…</div>
      <div style="font-size:11px;color:rgba(0,0,0,0.6)" id="latText">-- ms</div>
    </div>
  </div>

  <div class="wrap" role="main">
    <div class="count-box">
      <div class="count" id="countDisplay">0</div>
    </div>

    <div class="info">Press <strong>Space</strong> to add +1, <strong>Enter</strong> to subtract −1. Offline changes queue and sync on reconnect.</div>

    <div class="info" id="localInfo">Local queued changes: 0</div>

    <div class="goal-row" id="goalRow">
      <input id="goalInput" type="number" min="1" placeholder="Set goal" />
      <button id="setGoalBtn">Set Goal</button>
      <div id="goalLabel" style="font-weight:800;color:#000;margin-left:10px">Goal: —</div>
    </div>
  </div>

  <div class="goal-bottom" id="goalBottom" style="display:none">Goal: —</div>
  <div class="offline-bar" id="offlineBar">YOU ARE OFFLINE! Local changes will sync when you reconnect.</div>
  <div class="confetti" id="confettiLayer" aria-hidden="true"></div>

<script>
/* ---------- Firebase config (user-provided) ---------- */
const firebaseConfig = {
  apiKey: "AIzaSyCPU33ZcxWoS9NUaDEYJvNcB8FvVtdBTrg",
  authDomain: "notey-4455f.firebaseapp.com",
  databaseURL: "https://notey-4455f-default-rtdb.firebaseio.com",
  projectId: "notey-4455f",
  storageBucket: "notey-4455f.firebasestorage.app",
  messagingSenderId: "554664934050",
  appId: "1:554664934050:web:2e0a56b2dd0823cafa35fb",
  measurementId: "G-L0RJKWNMN7"
};
firebase.initializeApp(firebaseConfig);
const db = firebase.database();

/* ---------- Realtime DB refs ---------- */
const countRef = db.ref('/count');
const goalRef = db.ref('/goal');
const connectedRef = db.ref('.info/connected');
const goalPopupShownRef = db.ref('/goalPopupShown');

/* ---------- UI elements ---------- */
const countDisplay = document.getElementById('countDisplay');
const localInfo = document.getElementById('localInfo');
const offlineBar = document.getElementById('offlineBar');
const statusDot = document.getElementById('statusDot');
const statusText = document.getElementById('statusText');
const latText = document.getElementById('latText');
const goalInput = document.getElementById('goalInput');
const setGoalBtn = document.getElementById('setGoalBtn');
const goalLabel = document.getElementById('goalLabel');
const goalBottom = document.getElementById('goalBottom');
const confettiLayer = document.getElementById('confettiLayer');
const goalRow = document.getElementById('goalRow');

/* ---------- Local state ---------- */
let serverCount = 0;
let queuedDelta = 0;
let isConnected = false;
let currentGoal = null;
let confettiInterval = null;
let goalPopupShown = false;
let lastMeasuredLatency = null;

/* ---------- Render UI ---------- */
function render(){
  const shown = serverCount + queuedDelta;
  countDisplay.textContent = shown;
  localInfo.textContent = `Local queued changes: ${queuedDelta >= 0 ? '+'+queuedDelta : queuedDelta}`;
  offlineBar.style.display = isConnected ? 'none' : 'block';

  if (currentGoal === null) {
    goalLabel.textContent = 'Goal: —';
    goalBottom.style.display = 'none';
    // show input to set goal when none exists
    goalRow.style.display = 'flex';
  } else {
    goalLabel.textContent = `Goal: ${currentGoal}`;
    goalBottom.textContent = `Goal: ${currentGoal}`;
    goalBottom.style.display = 'block';
    goalRow.style.display = 'flex';
  }

  // confetti logic: if total >= goal -> confetti
  if (currentGoal !== null && shown >= currentGoal) startConfetti(); else stopConfetti();
}

/* ---------- Confetti (intense) ---------- */
const confettiColors = ['#ef4444','#f97316','#f59e0b','#10b981','#06b6d4','#3b82f6','#8b5cf6','#ec4899','#fde68a','#bbf7d0'];
function spawnConfettiPiece(){
  const el = document.createElement('div');
  el.className = 'confetti-piece';
  const w = 6 + Math.random()*20;
  const h = w * (0.8 + Math.random()*0.8);
  el.style.width = w + 'px';
  el.style.height = h + 'px';
  el.style.left = (Math.random()*100) + 'vw';
  el.style.top = '-12vh';
  el.style.background = confettiColors[Math.floor(Math.random()*confettiColors.length)];
  el.style.transform = `rotate(${Math.random()*360}deg)`;
  const dur = 1500 + Math.random()*2200;
  const drift = (Math.random()*200) - 100;
  el.animate([
    { transform: `translate(0px, 0vh) rotate(${Math.random()*360}deg)`, opacity:1 },
    { transform: `translate(${drift}px, ${110 + Math.random()*60}vh) rotate(${Math.random()*720}deg)`, opacity:0.15 }
  ], { duration: dur, easing: 'cubic-bezier(.2,.6,.2,1)' });
  confettiLayer.appendChild(el);
  setTimeout(()=> el.remove(), dur + 120);
}
function startConfetti(){
  if (confettiInterval) return;
  // big initial burst
  for (let i=0;i<140;i++) spawnConfettiPiece();
  confettiInterval = setInterval(()=> {
    const burst = 18 + Math.floor(Math.random()*30);
    for (let i=0;i<burst;i++) spawnConfettiPiece();
  }, 220);
}
function stopConfetti(){
  if (!confettiInterval) return;
  clearInterval(confettiInterval);
  confettiInterval = null;
}

/* ---------- Connection tracking + queued application ---------- */
connectedRef.on('value', snap => {
  isConnected = !!snap.val();
  updateStatusIndicator();
  render();

  if (isConnected && queuedDelta !== 0) {
    const deltaToSend = queuedDelta;
    queuedDelta = 0; // clear UI immediately
    render();
    // Apply queued delta with capping according to currentGoal and preventing negative values.
    countRef.transaction(current => {
      const base = (typeof current === 'number') ? current : (current ? Number(current) : 0);
      let target = base + deltaToSend;
      if (currentGoal !== null) {
        target = Math.min(target, currentGoal);
      }
      target = Math.max(0, target);
      return target;
    }, (err, committed, snapshot) => {
      if (err) {
        // restore queued delta if transaction failed
        queuedDelta += deltaToSend;
        console.error('Transaction failed when applying queued delta:', err);
      } else if (!committed) {
        queuedDelta += deltaToSend;
        console.warn('Transaction not committed; queued restored.');
      } else {
        // If some of the queued delta was blocked by goal cap, we won't requeue the blocked portion.
        // This implements "can't go bigger than the goal".
      }
      render();
    });
  }
});

/* ---------- Listen for remote changes ---------- */
countRef.on('value', snap => {
  const v = snap.val();
  serverCount = (typeof v === 'number') ? v : (v ? Number(v) : 0);
  render();
});

/* ---------- Goal listener ---------- */
goalRef.on('value', snap => {
  const v = snap.val();
  currentGoal = (v === null || v === undefined) ? null : Number(v);
  render();
});

/* ---------- Popup flag (keeps modal single-show behavior; not used visually here) ---------- */
goalPopupShownRef.on('value', snap => { goalPopupShown = !!snap.val(); });

/* ---------- Add/sub logic (keyboard only). Cap additions so you cannot exceed goal. ---------- */
function flashBlocked(){
  countDisplay.parentElement.classList.add('flash');
  setTimeout(()=> countDisplay.parentElement.classList.remove('flash'), 300);
}

function doAdd(n){
  // if adding, enforce goal cap on client side before attempting transaction
  const currentShown = serverCount + queuedDelta;
  if (n > 0 && currentGoal !== null) {
    if (currentShown >= currentGoal) {
      // already at or above goal: block
      flashBlocked();
      return;
    }
    // allowed increment (remaining)
    const remaining = currentGoal - currentShown;
    if (remaining <= 0) { flashBlocked(); return; }
    // if user tries to add more than remaining, limit to remaining
    if (n > remaining) n = remaining;
  }

  if (isConnected) {
    // Use transaction that caps to goal and prevents negative
    countRef.transaction(current => {
      const base = (typeof current === 'number') ? current : (current ? Number(current) : 0);
      let newVal = base + n;
      if (currentGoal !== null) newVal = Math.min(newVal, currentGoal);
      newVal = Math.max(0, newVal);
      return newVal;
    }, (err, committed) => {
      if (err) console.error('Transaction error:', err);
      if (!committed) console.warn('Transaction not committed.');
    });
  } else {
    // offline: queue delta locally but cap so queued won't push above goal
    if (n > 0 && currentGoal !== null) {
      const remaining = currentGoal - (serverCount + queuedDelta);
      if (remaining <= 0) { flashBlocked(); return; }
      if (n > remaining) n = remaining;
    }
    queuedDelta += n;
    render();
  }
}

/* keyboard handling: Space = +1, Enter = -1 (do not capture Enter when typing in inputs) */
window.addEventListener('keydown',(e)=>{
  if (e.code === 'Space') {
    e.preventDefault();
    doAdd(1);
  } else if (e.key === 'Enter') {
    const tag = (document.activeElement||{}).tagName;
    if (tag === 'INPUT' || tag === 'TEXTAREA') return;
    e.preventDefault();
    doAdd(-1);
  }
});

/* ---------- Goal set button ---------- */
setGoalBtn.addEventListener('click', ()=>{
  const val = Number(goalInput.value);
  if (!Number.isFinite(val) || val <= 0) { alert('Enter a positive integer goal.'); return; }
  // Persist goal for everyone. Per your earlier instruction, do NOT auto-clear goalPopupShown in DB.
  goalRef.set(val).then(()=> { goalInput.value=''; }).catch(err => {
    alert('Could not set goal while offline. Set goal requires connection.');
    console.error(err);
  });
});

/* ---------- Latency measurement and status colors ---------- */
function updateStatusIndicator(latencyMs){
  if (!isConnected) {
    statusDot.style.background = getComputedStyle(document.documentElement).getPropertyValue('--bad');
    statusText.textContent = 'Disconnected';
    latText.textContent = '-- ms';
    return;
  }
  lastMeasuredLatency = (typeof latencyMs === 'number') ? Math.round(latencyMs) : lastMeasuredLatency;
  // thresholds (ms): <250 green, 250-800 yellow, >800 red (but still "connected")
  if (lastMeasuredLatency === null) {
    statusDot.style.background = 'gray';
    statusText.textContent = 'Connected';
    latText.textContent = '-- ms';
    return;
  }
  latText.textContent = `${lastMeasuredLatency} ms`;
  if (lastMeasuredLatency < 250) {
    statusDot.style.background = getComputedStyle(document.documentElement).getPropertyValue('--good');
    statusText.textContent = 'Good';
  } else if (lastMeasuredLatency < 800) {
    statusDot.style.background = getComputedStyle(document.documentElement).getPropertyValue('--warn');
    statusText.textContent = 'Low';
  } else {
    statusDot.style.background = getComputedStyle(document.documentElement).getPropertyValue('--bad');
    statusText.textContent = 'Slow';
  }
}

/* measure latency by doing a lightweight read and timing the callback.
   This is approximate but works without extra DB writes. */
function measureLatencyOnce(){
  const t0 = performance.now();
  // Use a small once read on countRef
  countRef.once('value', ()=> {
    const t1 = performance.now();
    const ms = t1 - t0;
    updateStatusIndicator(ms);
  }, err => {
    // on error, mark disconnected and show
    updateStatusIndicator(null);
  });
}

/* run latency checks periodically while connected */
setInterval(()=>{
  if (isConnected) measureLatencyOnce();
  else updateStatusIndicator(null);
}, 3000);

/* initial status update */
updateStatusIndicator(null);

/* ---------- Initial render and optional seeding ---------- */
render();
/* optional: ensure count exists on DB first-time (commented out)
countRef.once('value').then(s=>{ if (s.val()===null) countRef.set(0); });
*/
</script>
</body>
</html>
