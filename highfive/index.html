<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Realtime Space Counter</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <style>
    :root { --muted: rgba(0,0,0,0.55); --good:#16a34a; --warn:#f59e0b; --bad:#ef4444; }
    html,body{height:100%;margin:0;font-family:Inter,system-ui,-apple-system,Segoe UI,Roboto,"Helvetica Neue",Arial}
    body{
      /* put your background image file next to this file and name it background.jpg */
      background-image: url("background.jpg");
      background-size: cover;
      background-position: center;
      background-repeat: no-repeat;
      display:flex;
      align-items:center;
      justify-content:center;
      color:#000;
    }

    .wrap{
      width:100%;
      max-width:980px;
      margin:24px;
      padding:24px;
      background: rgba(255,255,255,0.0);
      border-radius:18px;
      text-align:center;
      position:relative;
    }

    /* status badge top-right */
    .status-badge{
      position: fixed;
      top: 24px;
      right: 24px;
      display:flex;
      gap:16px;
      align-items:center;
      background: rgba(255,255,255,0.95);
      color:#000;
      padding:16px 20px;
      border-radius:16px;
      box-shadow: 0 8px 30px rgba(0,0,0,0.15);
      font-weight:700;
      font-size:18px;
      z-index:12000;
    }
    
    /* WiFi bars container */
    .wifi-bars{
      display:flex;
      align-items:flex-end;
      gap:4px;
      height:32px;
      width:40px;
    }
    .wifi-bar{
      flex:1;
      background: var(--muted);
      border-radius:2px;
      transition: background 0.3s ease, opacity 0.3s ease;
      opacity: 0.25;
    }
    .wifi-bar.active{
      opacity: 1;
    }
    .wifi-bar:nth-child(1){ height: 25%; }
    .wifi-bar:nth-child(2){ height: 50%; }
    .wifi-bar:nth-child(3){ height: 75%; }
    .wifi-bar:nth-child(4){ height: 100%; }
    
    .status-text { font-size:18px; color: #000; font-weight:700; }

    /* big centered number */
    .count-box{
      display:flex;
      align-items:center;
      justify-content:center;
      width:100%;
      height:260px;
      margin:10px auto;
      user-select:none;
      background: rgba(255,255,255,0.92); /* white panel so black number is readable */
      border-radius:20px;
      box-shadow: 0 10px 40px rgba(0,0,0,0.12);
    }
    .count{
      font-size:140px;
      font-weight:900;
      color:#000;
      line-height:0.95;
    }

    .info { color:white; margin-top:12px; font-size:14px; }

    /* local queued info */
    .local { color:var(--muted); font-size:13px; margin-top:10px; }

    /* goal UI row */
    .goal-row { margin-top:14px; display:flex; gap:8px; align-items:center; justify-content:center; }
    input[type=number] { padding:8px 10px; border-radius:8px; border:1px solid rgba(0,0,0,0.08); background:rgba(255,255,255,0.95); color:#000; width:130px; text-align:center; font-weight:700; }
    button { padding:9px 12px; border-radius:10px; border:1px solid rgba(0,0,0,0.08); background:rgba(255,255,255,0.95); font-weight:700; cursor:pointer; }

    /* large goal bottom center */
    .goal-bottom{
      position: fixed;
      left: 50%;
      transform: translateX(-50%);
      bottom: 18px;
      background: rgba(255,255,255,0.92);
      padding:12px 20px;
      border-radius:999px;
      box-shadow:0 8px 30px rgba(0,0,0,0.12);
      font-weight:900;
      font-size:22px;
      color:#000;
      z-index:11000;
    }

    .offline-bar { position:fixed; left:0; right:0; bottom:0; background:#b91c1c; color:white; padding:10px 14px; text-align:center; font-weight:700; display:none; z-index:9999; }

    /* confetti */
    .confetti{ position: fixed; pointer-events:none; left:0; top:0; right:0; bottom:0; overflow:visible; z-index:9998; }
    .confetti-piece{ position:absolute; width:10px; height:14px; opacity:0.95; transform-origin:center; will-change: transform, top, left; border-radius:2px; }

    /* bubble animation */
    .bubble-container{ position: fixed; pointer-events:none; left:0; top:0; right:0; bottom:0; overflow:hidden; z-index:9997; }
    .bubble{
      position:absolute;
      border-radius:50%;
      background: linear-gradient(135deg, rgba(255,255,255,0.8) 0%, rgba(255,255,255,0.3) 50%, rgba(255,255,255,0.1) 100%);
      box-shadow: inset 0 0 15px rgba(255,255,255,0.6), 0 5px 15px rgba(0,0,0,0.1);
      will-change: transform, top, left, opacity;
    }
    .bubble::before{
      content: '';
      position: absolute;
      top: 10%;
      left: 15%;
      width: 40%;
      height: 40%;
      background: radial-gradient(circle, rgba(255,255,255,0.9) 0%, transparent 70%);
      border-radius: 50%;
    }

    /* small flash when blocked */
    .flash{
      animation: flashAnim 280ms ease-in-out;
    }
    @keyframes flashAnim {
      0% { box-shadow: 0 0 0 0 rgba(239,68,68,0.0); transform: scale(1); }
      40% { box-shadow: 0 0 0 10px rgba(239,68,68,0.08); transform: scale(1.02); }
      100% { box-shadow: 0 0 0 0 rgba(239,68,68,0.0); transform: scale(1); }
    }
    
    /* pulse animation for count increase */
    .pulse{
      animation: pulseAnim 300ms ease-out;
    }
    @keyframes pulseAnim {
      0% { transform: scale(1); }
      50% { transform: scale(1.05); }
      100% { transform: scale(1); }
    }
  </style>

  <!-- Firebase compat SDK -->
  <script src="https://www.gstatic.com/firebasejs/9.22.1/firebase-app-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.22.1/firebase-database-compat.js"></script>
</head>
<body>
  <div class="status-badge" id="statusBadge" aria-live="polite">
    <div class="wifi-bars" id="wifiBars" title="connection strength">
      <div class="wifi-bar"></div>
      <div class="wifi-bar"></div>
      <div class="wifi-bar"></div>
      <div class="wifi-bar"></div>
    </div>
    <div>
      <div class="status-text" id="statusText">Connecting…</div>
      <div style="font-size:15px;color:rgba(0,0,0,0.6);font-weight:600" id="latText">-- ms</div>
    </div>
  </div>

  <div class="wrap" role="main">
    <div class="count-box">
      <div class="count" id="countDisplay">0</div>
    </div>

    <div class="info">Press <strong>Space</strong> to add +1, <strong>Enter</strong> to subtract −1. Offline changes queue and sync on reconnect.</div>

    <div class="info" id="localInfo">Local queued changes: 0</div>

    <div class="goal-row" id="goalRow">
      <input id="goalInput" type="number" min="1" placeholder="Set goal" />
      <button id="setGoalBtn">Set Goal</button>
      <div id="goalLabel" style="font-weight:800;color:#000;margin-left:10px">Goal: —</div>
    </div>
  </div>

  <div class="goal-bottom" id="goalBottom" style="display:none">Goal: —</div>
  <div class="offline-bar" id="offlineBar">YOU ARE OFFLINE! Local changes will sync when you reconnect.</div>
  <div class="confetti" id="confettiLayer" aria-hidden="true"></div>
  <div class="bubble-container" id="bubbleContainer" aria-hidden="true"></div>

<script>
/* ---------- Firebase config (user-provided) ---------- */
const firebaseConfig = {
  apiKey: "AIzaSyCPU33ZcxWoS9NUaDEYJvNcB8FvVtdBTrg",
  authDomain: "notey-4455f.firebaseapp.com",
  databaseURL: "https://notey-4455f-default-rtdb.firebaseio.com",
  projectId: "notey-4455f",
  storageBucket: "notey-4455f.firebasestorage.app",
  messagingSenderId: "554664934050",
  appId: "1:554664934050:web:2e0a56b2dd0823cafa35fb",
  measurementId: "G-L0RJKWNMN7"
};
firebase.initializeApp(firebaseConfig);
const db = firebase.database();

/* ---------- Realtime DB refs ---------- */
const countRef = db.ref('/count');
const goalRef = db.ref('/goal');
const connectedRef = db.ref('.info/connected');
const goalPopupShownRef = db.ref('/goalPopupShown');

/* ---------- UI elements ---------- */
const countDisplay = document.getElementById('countDisplay');
const localInfo = document.getElementById('localInfo');
const offlineBar = document.getElementById('offlineBar');
const wifiBars = document.getElementById('wifiBars');
const statusText = document.getElementById('statusText');
const latText = document.getElementById('latText');
const goalInput = document.getElementById('goalInput');
const setGoalBtn = document.getElementById('setGoalBtn');
const goalLabel = document.getElementById('goalLabel');
const goalBottom = document.getElementById('goalBottom');
const confettiLayer = document.getElementById('confettiLayer');
const goalRow = document.getElementById('goalRow');
const bubbleContainer = document.getElementById('bubbleContainer');

/* ---------- Sound Effects ---------- */
const audioContext = new (window.AudioContext || window.webkitAudioContext)();

function playPopSound() {
  const oscillator = audioContext.createOscillator();
  const gainNode = audioContext.createGain();
  
  oscillator.connect(gainNode);
  gainNode.connect(audioContext.destination);
  
  oscillator.frequency.setValueAtTime(800, audioContext.currentTime);
  oscillator.frequency.exponentialRampToValueAtTime(400, audioContext.currentTime + 0.1);
  
  gainNode.gain.setValueAtTime(0.3, audioContext.currentTime);
  gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.1);
  
  oscillator.start(audioContext.currentTime);
  oscillator.stop(audioContext.currentTime + 0.1);
}

function playSubtractSound() {
  const oscillator = audioContext.createOscillator();
  const gainNode = audioContext.createGain();
  
  oscillator.connect(gainNode);
  gainNode.connect(audioContext.destination);
  
  oscillator.frequency.setValueAtTime(400, audioContext.currentTime);
  oscillator.frequency.exponentialRampToValueAtTime(200, audioContext.currentTime + 0.15);
  
  gainNode.gain.setValueAtTime(0.2, audioContext.currentTime);
  gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.15);
  
  oscillator.start(audioContext.currentTime);
  oscillator.stop(audioContext.currentTime + 0.15);
}

function playGoalSound() {
  // Victory fanfare with multiple notes
  const notes = [
    { freq: 523.25, time: 0, duration: 0.15 },      // C5
    { freq: 659.25, time: 0.15, duration: 0.15 },   // E5
    { freq: 783.99, time: 0.3, duration: 0.15 },    // G5
    { freq: 1046.50, time: 0.45, duration: 0.4 }    // C6 (held)
  ];
  
  notes.forEach(note => {
    const oscillator = audioContext.createOscillator();
    const gainNode = audioContext.createGain();
    
    oscillator.connect(gainNode);
    gainNode.connect(audioContext.destination);
    
    oscillator.frequency.setValueAtTime(note.freq, audioContext.currentTime + note.time);
    
    gainNode.gain.setValueAtTime(0, audioContext.currentTime + note.time);
    gainNode.gain.linearRampToValueAtTime(0.3, audioContext.currentTime + note.time + 0.02);
    gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + note.time + note.duration);
    
    oscillator.start(audioContext.currentTime + note.time);
    oscillator.stop(audioContext.currentTime + note.time + note.duration);
  });
}

/* ---------- Local state ---------- */
let serverCount = 0;
let previousCount = 0; // Track previous count for animations
let queuedDelta = 0;
let isConnected = false;
let currentGoal = null;
let confettiInterval = null;
let goalPopupShown = false;
let goalSoundPlayed = false; // Track if we've played the goal sound

/* ---------- Latency tracking ---------- */
let samples = [];
const MAX_SAMPLES = 5;
let currentBars = 2;
let retrying = false;
const TEST_URL = "https://noteyai.github.io/highfive";

/* ---------- Render UI ---------- */
function render(){
  const shown = serverCount + queuedDelta;
  
  // Check if count increased to trigger effects
  if (shown > previousCount) {
    playPopSound();
    triggerBubbles(3);
    countDisplay.classList.add('pulse');
    setTimeout(() => countDisplay.classList.remove('pulse'), 300);
  } else if (shown < previousCount) {
    playSubtractSound();
  }
  
  previousCount = shown;
  countDisplay.textContent = shown;
  localInfo.textContent = `Local queued changes: ${queuedDelta >= 0 ? '+'+queuedDelta : queuedDelta}`;
  offlineBar.style.display = isConnected ? 'none' : 'block';

  if (currentGoal === null) {
    goalLabel.textContent = 'Goal: —';
    goalBottom.style.display = 'none';
    goalRow.style.display = 'flex';
    goalSoundPlayed = false; // Reset when no goal
  } else {
    goalLabel.textContent = `Goal: ${currentGoal}`;
    goalBottom.textContent = `Goal: ${currentGoal}`;
    goalBottom.style.display = 'block';
    goalRow.style.display = 'flex';
  }

  // confetti logic and goal sound: if total >= goal -> confetti + sound
  if (currentGoal !== null && shown >= currentGoal) {
    if (!goalSoundPlayed) {
      playGoalSound();
      goalSoundPlayed = true;
    }
    startConfetti();
  } else {
    stopConfetti();
    if (currentGoal !== null && shown < currentGoal) {
      goalSoundPlayed = false; // Reset if we go below goal
    }
  }
}

/* ---------- Confetti (intense) ---------- */
const confettiColors = ['#ef4444','#f97316','#f59e0b','#10b981','#06b6d4','#3b82f6','#8b5cf6','#ec4899','#fde68a','#bbf7d0'];
function spawnConfettiPiece(){
  const el = document.createElement('div');
  el.className = 'confetti-piece';
  const w = 6 + Math.random()*20;
  const h = w * (0.8 + Math.random()*0.8);
  el.style.width = w + 'px';
  el.style.height = h + 'px';
  el.style.left = (Math.random()*100) + 'vw';
  el.style.top = '-12vh';
  el.style.background = confettiColors[Math.floor(Math.random()*confettiColors.length)];
  el.style.transform = `rotate(${Math.random()*360}deg)`;
  const dur = 1500 + Math.random()*2200;
  const drift = (Math.random()*200) - 100;
  el.animate([
    { transform: `translate(0px, 0vh) rotate(${Math.random()*360}deg)`, opacity:1 },
    { transform: `translate(${drift}px, ${110 + Math.random()*60}vh) rotate(${Math.random()*720}deg)`, opacity:0.15 }
  ], { duration: dur, easing: 'cubic-bezier(.2,.6,.2,1)' });
  confettiLayer.appendChild(el);
  setTimeout(()=> el.remove(), dur + 120);
}
function startConfetti(){
  if (confettiInterval) return;
  // big initial burst
  for (let i=0;i<140;i++) spawnConfettiPiece();
  confettiInterval = setInterval(()=> {
    const burst = 18 + Math.floor(Math.random()*30);
    for (let i=0;i<burst;i++) spawnConfettiPiece();
  }, 220);
}
function stopConfetti(){
  if (!confettiInterval) return;
  clearInterval(confettiInterval);
  confettiInterval = null;
}

/* ---------- Bubble Animation ---------- */
function spawnBubble() {
  const bubble = document.createElement('div');
  bubble.className = 'bubble';
  
  const size = 30 + Math.random() * 60;
  bubble.style.width = size + 'px';
  bubble.style.height = size + 'px';
  bubble.style.left = (Math.random() * 100) + 'vw';
  bubble.style.bottom = '-100px';
  
  const duration = 2000 + Math.random() * 2000;
  const drift = (Math.random() * 100) - 50;
  const wobble = Math.random() * 30 - 15;
  
  bubble.animate([
    { 
      transform: `translateX(0px) translateY(0px) scale(0.8)`, 
      opacity: 0 
    },
    { 
      transform: `translateX(${drift/2}px) translateY(-50vh) scale(1)`, 
      opacity: 0.8,
      offset: 0.3
    },
    { 
      transform: `translateX(${drift + wobble}px) translateY(-110vh) scale(0.6)`, 
      opacity: 0 
    }
  ], { 
    duration: duration, 
    easing: 'ease-out' 
  });
  
  bubbleContainer.appendChild(bubble);
  setTimeout(() => bubble.remove(), duration);
}

function triggerBubbles(count = 5) {
  for (let i = 0; i < count; i++) {
    setTimeout(() => spawnBubble(), i * 50);
  }
}

/* ---------- Connection tracking + queued application ---------- */
connectedRef.on('value', snap => {
  const wasConnected = isConnected;
  isConnected = !!snap.val();
  
  updateStatusIndicator();
  render();

  if (isConnected && queuedDelta !== 0) {
    const deltaToSend = queuedDelta;
    queuedDelta = 0; // clear UI immediately
    render();
    // Apply queued delta with capping according to currentGoal and preventing negative values.
    countRef.transaction(current => {
      const base = (typeof current === 'number') ? current : (current ? Number(current) : 0);
      let target = base + deltaToSend;
      if (currentGoal !== null) {
        target = Math.min(target, currentGoal);
      }
      target = Math.max(0, target);
      return target;
    }, (err, committed, snapshot) => {
      if (err) {
        // restore queued delta if transaction failed
        queuedDelta += deltaToSend;
        console.error('Transaction failed when applying queued delta:', err);
      } else if (!committed) {
        queuedDelta += deltaToSend;
        console.warn('Transaction not committed; queued restored.');
      } else {
        // If some of the queued delta was blocked by goal cap, we won't requeue the blocked portion.
        // This implements "can't go bigger than the goal".
      }
      render();
    });
  }
});

/* ---------- Listen for remote changes ---------- */
countRef.on('value', snap => {
  const v = snap.val();
  serverCount = (typeof v === 'number') ? v : (v ? Number(v) : 0);
  render();
});

/* ---------- Goal listener ---------- */
goalRef.on('value', snap => {
  const v = snap.val();
  currentGoal = (v === null || v === undefined) ? null : Number(v);
  render();
});

/* ---------- Popup flag (keeps modal single-show behavior; not used visually here) ---------- */
goalPopupShownRef.on('value', snap => { goalPopupShown = !!snap.val(); });

/* ---------- Add/sub logic (keyboard only). Cap additions so you cannot exceed goal. ---------- */
function flashBlocked(){
  countDisplay.parentElement.classList.add('flash');
  setTimeout(()=> countDisplay.parentElement.classList.remove('flash'), 300);
}

function doAdd(n){
  // if adding, enforce goal cap on client side before attempting transaction
  const currentShown = serverCount + queuedDelta;
  if (n > 0 && currentGoal !== null) {
    if (currentShown >= currentGoal) {
      // already at or above goal: block
      flashBlocked();
      return;
    }
    // allowed increment (remaining)
    const remaining = currentGoal - currentShown;
    if (remaining <= 0) { flashBlocked(); return; }
    // if user tries to add more than remaining, limit to remaining
    if (n > remaining) n = remaining;
  }

  if (isConnected) {
    // Use transaction that caps to goal and prevents negative
    countRef.transaction(current => {
      const base = (typeof current === 'number') ? current : (current ? Number(current) : 0);
      let newVal = base + n;
      if (currentGoal !== null) newVal = Math.min(newVal, currentGoal);
      newVal = Math.max(0, newVal);
      return newVal;
    }, (err, committed) => {
      if (err) console.error('Transaction error:', err);
      if (!committed) console.warn('Transaction not committed.');
    });
  } else {
    // offline: queue delta locally but cap so queued won't push above goal
    if (n > 0 && currentGoal !== null) {
      const remaining = currentGoal - (serverCount + queuedDelta);
      if (remaining <= 0) { flashBlocked(); return; }
      if (n > remaining) n = remaining;
    }
    queuedDelta += n;
    render();
  }
}

/* keyboard handling: Space = +1, Enter = -1 (do not capture Enter when typing in inputs) */
window.addEventListener('keydown',(e)=>{
  if (e.code === 'Space') {
    e.preventDefault();
    doAdd(1);
  } else if (e.key === 'Enter') {
    const tag = (document.activeElement||{}).tagName;
    if (tag === 'INPUT' || tag === 'TEXTAREA') return;
    e.preventDefault();
    doAdd(-1);
  }
});

/* ---------- Goal set button ---------- */
setGoalBtn.addEventListener('click', ()=>{
  const val = Number(goalInput.value);
  if (!Number.isFinite(val) || val <= 0) { alert('Enter a positive integer goal.'); return; }
  // Persist goal for everyone. Per your earlier instruction, do NOT auto-clear goalPopupShown in DB.
  goalRef.set(val).then(()=> { goalInput.value=''; }).catch(err => {
    alert('Could not set goal while offline. Set goal requires connection.');
    console.error(err);
  });
});

/* ---------- Connection Monitoring with Ping ---------- */
function latencyToBars(ms) {
  if (ms < 100) return 4;
  if (ms < 200) return 3;
  if (ms < 300) return 2;
  // Anything 300+ stays at 1 bar until complete disconnect
  return 1;
}

async function pingUntilLoaded() {
  const url = TEST_URL + "?ping=" + Date.now();
  const start = performance.now();
  try {
    await fetch(url, { cache: "no-store", mode: "no-cors" });
    const latency = performance.now() - start;
    
    // No more immediate retry based on latency - let high latency show as 1 bar
    retrying = false;
    samples.push(latency);
    if (samples.length > MAX_SAMPLES) samples.shift();
    
    const avg = samples.reduce((a, b) => a + b, 0) / samples.length;
    const targetBars = latencyToBars(avg);
    
    // Smooth bar change ±1
    if (targetBars > currentBars) currentBars++;
    else if (targetBars < currentBars) currentBars--;
    
    updateStatusIndicator(avg);
  } catch {
    // Only retry on complete connection failure
    retrying = true;
    currentBars = 0; // No bars on complete disconnect
    samples = []; // Clear samples on disconnect
    updateStatusIndicator(null);
    requestAnimationFrame(pingUntilLoaded);
  }
}

function startConnectionMonitor() {
  if (!retrying) pingUntilLoaded();
}

/* ---------- Status indicator with WiFi bars ---------- */
function updateStatusIndicator(latencyMs){
  const bars = wifiBars.querySelectorAll('.wifi-bar');
  
  if (!isConnected) {
    // No bars when disconnected
    bars.forEach(bar => {
      bar.classList.remove('active');
      bar.style.background = getComputedStyle(document.documentElement).getPropertyValue('--bad');
    });
    statusText.textContent = 'Disconnected';
    latText.textContent = '-- ms';
    return;
  }
  
  // If retrying or no latency data
  if (latencyMs === null || latencyMs === undefined) {
    statusText.textContent = 'Measuring...';
    latText.textContent = '-- ms';
    // Show current bars level while measuring
    bars.forEach((bar, index) => {
      if (index < currentBars) {
        bar.classList.add('active');
        bar.style.background = '#999';
      } else {
        bar.classList.remove('active');
        bar.style.background = getComputedStyle(document.documentElement).getPropertyValue('--muted');
      }
    });
    return;
  }
  
  // Round to 1 decimal place for display
  const roundedLatency = Math.round(latencyMs * 10) / 10;
  latText.textContent = `${roundedLatency} ms`;
  
  // Determine color and status text based on latency
  let barColor = '';
  
  if (latencyMs < 100) {
    // 4 bars - Excellent
    barColor = getComputedStyle(document.documentElement).getPropertyValue('--good');
    statusText.textContent = 'Excellent';
  } else if (latencyMs < 200) {
    // 3 bars - Good
    barColor = getComputedStyle(document.documentElement).getPropertyValue('--good');
    statusText.textContent = 'Good';
  } else if (latencyMs < 300) {
    // 2 bars - Fair
    barColor = getComputedStyle(document.documentElement).getPropertyValue('--warn');
    statusText.textContent = 'Fair';
  } else {
    // 1 bar - Slow (300+)
    barColor = getComputedStyle(document.documentElement).getPropertyValue('--bad');
    statusText.textContent = 'Slow';
  }
  
  // Update bars - use currentBars for smooth transitions
  bars.forEach((bar, index) => {
    if (index < currentBars) {
      bar.classList.add('active');
      bar.style.background = barColor;
    } else {
      bar.classList.remove('active');
      bar.style.background = getComputedStyle(document.documentElement).getPropertyValue('--muted');
    }
  });
}

/* ---------- Initial status update ---------- */
updateStatusIndicator(null);

/* ---------- Start connection monitoring ---------- */
startConnectionMonitor();
setInterval(startConnectionMonitor, 5000);

/* ---------- Initial render ---------- */
render();

/* ---------- Cleanup on page unload ---------- */
window.addEventListener('beforeunload', () => {
  retrying = false;
});
</script>
</body>
</html>
